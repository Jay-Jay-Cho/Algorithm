

# [등굣길](https://programmers.co.kr/learn/courses/30/lessons/42898)
* **참고자료** : https://jar100.tistory.com/27
* **참고자료** : https://selina-park.tistory.com/140
<br>

## &#10095;&#10095;&#10095; 전체 코드
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int answer = getAnswer(m,n,puddles);
        return answer;
    }

    public int getAnswer(int m, int n, int[][] puddles){
        int answer = 0;

        int[][] dp = new int[n+1][m+1];             
        dp[1][1] = 1;

        for(int i=0;i<puddles.length;i++){
            dp[puddles[i][1]][puddles[i][0]] = -1;
        }

        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(dp[i][j]==-1) continue;
                //from left
                if(dp[i-1][j]!=-1 && dp[i][j]!=-1) {
                	dp[i][j] += dp[i-1][j]%1000000007;
                }
                //from up
                if(dp[i][j-1]!=-1 && dp[i][j]!=-1) {
                	dp[i][j] += dp[i][j-1]%1000000007;
                }
            }
        }

        return dp[n][m]%1000000007;
    }
}
```
<br><br>

## &#10095;&#10095;&#10095; 설명
* Level : 3
* DP
* 목적지(n,m)에 도착하는 최단경로의 갯수 찾기
<br><br>


## &#10095;&#10095;&#10095; 접근법   
* 최단경로를 구하는 여러 가지 방법들(벨만포드, 다익스트라 등)이 있지만, DP를 이용한 최단경로는 처음이었기 때문에 처음에는 아예 접근 자체를 못했다. 그래서 [참고자료](https://jar100.tistory.com/27)를 통해 구현.....
![dp_최단거리](/assets/dp_최단거리.gif)
* 풀이하자면, 어차피 최단경로는 **오른쪽** 혹은 **아래쪽** 으로만 진행이 가능하기 때문에, n번째 좌표에서의 최단 경로는 `좌측 혹은 위쪽에서 오는 경로들의 합`이라는 것이다!!!
* 또한 유의할 점은,
  * 문제에서 주어진 m,n은 x,y와 **반대** 이기 때문에 각 배열에 값을 넣을 때는 x=n, y=m과 대칭시킬 것.
  * 격자의 크기가 최대 100*100까지 커질 수 있기 때문에, 경로의 갯수를 더해줄 때도 1,000,000,007로 나눈 나머지로 넣어줄 것. 그렇지 않고, 값 자체를 넣으면 효율성에서 탈락....
  * (a+b+c+...)%1,000,000,007 이나, (a%1,000,000,007)+(b%1,000,000,007)+(c%1,000,000,007)+...이나 **나머지는 똑같기 때문**
<br><br>

## &#10095;&#10095;&#10095; 풀이
##### 1. 경로 값들을 저장할 2차원 배열 선언 및 시작점(1) 초기화.
* (x,y)는 (m,n)이 아니라 (n,m)이다.
```java
int[][] dp = new int[n+1][m+1];             
dp[1][1] = 1;
```
<br>

##### 2. 물 웅덩이 좌표에는 -1로 초기화.
* 물 웅덩이의 경우에도, (x,y)좌표가 바껴야 한다.
  * 물 웅덩이 좌표가 (2,3)이면, 실제 2차원 배열에는 (3,2)로 들어가야....
```java
for(int i=0;i<puddles.length;i++){
    dp[puddles[i][1]][puddles[i][0]] = -1;
}
```
<br>

##### 3. 시작점(1,1)부터 시작해서 점화식을 따라 목적지까지 dp 진행.
* `dp[i-1][j]!=-1 && dp[i][j]!=-1` = 좌측(`i-1,j`)과 현재 위치(`i,j`)가 물 웅덩이가 아니면
* `dp[i][j-1]!=-1 && dp[i][j]!=-1` = 위쪽(`i,j-1`)과 현재 위치(`i,j`)가 물 웅덩이가 아니면
```java
for(int i=1;i<=n;i++){  // x = n
    for(int j=1;j<=m;j++){  // y = m
        // 물 웅덩이를 만나면 그냥 진행
        if(dp[i][j]==-1) continue;


        //from left
        if(dp[i-1][j]!=-1 && dp[i][j]!=-1) {
          // 경로 수를 누적시킨다.
          dp[i][j] += dp[i-1][j]%1000000007;
        }


        //from up
        if(dp[i][j-1]!=-1 && dp[i][j]!=-1) {
          dp[i][j] += dp[i][j-1]%1000000007;
        }
    }
}
```
<br>

##### 4. 목적지까지 누적된 경로의 합을 출력.
```java
return dp[n][m]%1000000007;
```
<br><br>




## &#10095;&#10095;&#10095; 꿀팁

<br><br>


## &#10095;&#10095;&#10095; 숙지해야할 점 & 실수
* DP를 이용한 최단경로 문제에서는, 모든 방향이 아니라 특정 방향(**like 오른쪽&아래쪽**)만 고려할 것.
* 문제에서 주어지는 좌표가 (x,y)인지 (y,x)인지 잘 파악할 것.


<br>
<br>
<br>
